CREATE DATABASE sql_training;
CREATE SCHEMA deleted;

-- Change between schemas for this connection. For now, ensure that you're on the public schema
SET search_path TO public;
-- FYI, to change to another schema, you can do this:
-- SET search_path to deleted, public
-- It will look for a table in the deleted schema first. If it doesn't find it, 
-- it will check the next schema till it finds it or runs out of options.

-- PG 10 way
CREATE TABLE public.locations (
  id integer NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  uid uuid NOT NULL,
  created_at timestamp NOT NULL DEFAULT current_timestamp,
  updated_at timestamp NOT NULL DEFAULT current_timestamp,
  name varchar(255) NOT NULL DEFAULT ''
);

-- PG 9.6 way
CREATE TABLE public.locations (
  id serial NOT NULL PRIMARY KEY,
  uid uuid NOT NULL,
  created_at timestamp NOT NULL DEFAULT current_timestamp,
  updated_at timestamp NOT NULL DEFAULT current_timestamp,
  name varchar(255) NOT NULL DEFAULT ''
);

-- copy table. deleted will not have a sequence or default values.
CREATE TABLE deleted.locations AS
  TABLE public.locations;

-- Create some indices
CREATE UNIQUE INDEX IF NOT EXISTS idx_location_uid ON public.locations (uid);
CREATE UNIQUE INDEX IF NOT EXISTS idx_location_uid ON deleted.locations (uid);
CREATE UNIQUE INDEX IF NOT EXISTS idx_location_name ON public.locations (name);
CREATE UNIQUE INDEX IF NOT EXISTS idx_location_name ON deleted.locations (name);
CREATE UNIQUE INDEX IF NOT EXISTS idx_location_id ON deleted.locations (id);

-- Multi Upsert a few rows. https://www.uuidgenerator.net is a good place to get a few sample UUIDs
-- EXCLUDED means "new data from this insert statement". In other words, if it conflicts
-- on the uid column, it will overwrite the name field with what's in this query. Because we didn't
-- specify the other columns like updated_at, these will not change. 
INSERT INTO public.locations (uid, name) VALUES
  ('219ce988-ac33-4ce9-bbbe-0453b44416d9','ogden'),
  ('2be779dd-c4d1-412b-ab4d-22742b39681c','salt lake city'),
  ('b4aa609b-e3a4-40bd-baf8-d2dbe9786014','provo')
  ON CONFLICT (uid) DO UPDATE SET name = EXCLUDED.name;

-- Should have some rows in the public schema, but not the deleted schema yet.
select * from public.locations;
-- 3
select * from deleted.locations;
-- 0

-- Common table expressions (CTEs) puts stuff in the WITH into the assigned variable in memory. 
-- Since we're returning *, all of the data from the delete will be available in the variable "items".
-- That is then inserted using the "INSERT INTO (SELECT)" pattern.
WITH items AS (
     DELETE FROM public.locations
     WHERE name = 'ogden'
     RETURNING *
)
INSERT INTO deleted.locations SELECT * FROM items;

-- Now one of the rows will be in deleted.
select * from public.locations;
-- 2
select * from deleted.locations;
-- 1

-- To show that sequences are still working, insert another row
INSERT INTO public.locations (uid, name) VALUES
  ('ea31deb7-9e91-479a-b838-bfc1490091c9','st. george')
  ON CONFLICT (uid) DO UPDATE SET name = EXCLUDED.name;

select * from public.locations;
-- 3
select * from deleted.locations;
-- 1

-- Now we'll undelete the row.  This is the same as before, but the schemas (public and deleted) are swapped.
WITH items AS (
     DELETE FROM deleted.locations
     WHERE name = 'ogden'
     RETURNING *
)
INSERT INTO public.locations SELECT * FROM items;

-- You'll notice that the ogden row shows up last.  This is because it was literally just inserted, and by default, 
-- PG will return rows in inserted order (and we don't have an order by clause). This is ok. 
select * from public.locations;
-- 4
select * from deleted.locations;
-- 0

-- Now insert one more row to prove that you get the right sequence, even though another row was just inserted.
INSERT INTO public.locations (uid, name) VALUES
  ('14511184-cfe8-4cc7-af1f-730aa6896876','cedar city')
  ON CONFLICT (uid) DO UPDATE SET name = EXCLUDED.name;

select * from public.locations;
-- 5
select * from deleted.locations;
-- 0
